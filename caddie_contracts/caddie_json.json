{"language":"Solidity","sources":{"src/CaddieGPT.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\n// Uncomment this line to use console.log\n// import \"hardhat/console.sol\";\nimport { IOracle } from \"./interfaces/IOracle.sol\";\nimport \"./CaddieGPT.sol\";\nimport \"./CaddieGPT.sol\";\n\n// @title ChatGpt\n// @notice This contract handles chat interactions and integrates with teeML oracle for LLM and knowledge base queries.\ncontract CaddieGPT {\n    address private owner;\n    address public oracleAddress;\n\n    // @notice CID of the knowledge base\n    string public knowledgeBase;\n    string public instruction;\n    uint256 private proposalCount;\n\n    struct CandidateProposal {\n        address owner;\n        uint256 id;\n        string title;\n        string body;\n        string summarizedBody;\n        string improvedTitle;\n        string improvedBody;\n        uint8 iteration;\n        uint8 possibleOutcome;\n        uint8 messagesCount;\n    }\n\n    struct MessageContent {\n        string contentType;\n        string value;\n    }\n\n    struct Message {\n        string role;\n        MessageContent content;\n    }\n\n    mapping(uint256 => CandidateProposal) public proposals;\n    mapping(uint256 => mapping(uint256 => Message)) public messages;\n\n    // @notice Event emitted when a new chat is created\n    event ChatCreated(address indexed owner, uint256 indexed chatId);\n    event ProposalSubmitted(uint256);\n    event OracleAddressUpdated(address indexed newOracleAddress);\n    event KnowledgeBaseUpdated(string newKnowledgeBase);\n    event InstructionUpdated(string newInstruction);\n\n    // @param initialOracleAddress Initial address of the oracle contract\n    // @param knowledgeBaseCID CID of the initial knowledge base\n    constructor(address initialOracleAddress, string memory knowledgeBaseCID, string memory instructionString) {\n        owner = msg.sender;\n        oracleAddress = initialOracleAddress;\n        knowledgeBase = knowledgeBaseCID;\n        instruction = instructionString;\n    }\n\n    // @notice Ensures the caller is the contract owner\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not Owner\");\n        _;\n    }\n\n    // @notice Ensures the caller is the oracle contract\n    modifier onlyOracle() {\n        require(msg.sender == oracleAddress, \"Not oracle\");\n        _;\n    }\n\n    // @notice Sets a new oracle address\n    // @param newOracleAddress The new oracle address\n    function setOracleAddress(address newOracleAddress) public onlyOwner {\n        oracleAddress = newOracleAddress;\n        emit OracleAddressUpdated(newOracleAddress);\n    }\n\n    function setKnowledgeBase(string memory newKnowledgeBase) public onlyOwner {\n        knowledgeBase = newKnowledgeBase;\n        emit KnowledgeBaseUpdated(newKnowledgeBase);\n    }\n\n    function setInstruction(string memory newInstruction) public onlyOwner {\n        instruction = newInstruction;\n        emit InstructionUpdated(newInstruction);\n    }\n\n    // @notice Starts a new chat\n    // @param message The initial message to start the chat with\n    // @return The ID of the newly created chat\n    function checkProposal(string memory proposalTitle, string memory proposalBody) public returns (uint256) {\n        CandidateProposal memory _proposal = CandidateProposal({\n            owner: msg.sender,\n            id: proposalCount,\n            title: proposalTitle,\n            body: proposalBody,\n            summarizedBody: \"\",\n            improvedTitle: \"\",\n            improvedBody: \"\",\n            iteration: 0,\n            possibleOutcome: 0,\n            messagesCount: 1\n        });\n        uint256 currentProposalId = proposalCount;\n        proposalCount++;\n        proposals[currentProposalId] = _proposal;\n\n        string memory message = concatenateProposal(proposalTitle, proposalBody);\n        Message memory newMessage = createTextMessage(\"user\", message);\n        messages[currentProposalId][0] = newMessage;\n        _proposal.messagesCount++;\n        // If there is a knowledge base, create a knowledge base query\n        if (bytes(knowledgeBase).length > 0) {\n            IOracle(oracleAddress).createKnowledgeBaseQuery(currentProposalId, knowledgeBase, message, 3);\n        } else {\n            // Otherwise, create an LLM call\n            IOracle(oracleAddress).createLlmCall(currentProposalId);\n        }\n\n        emit ProposalSubmitted(currentProposalId);\n        return currentProposalId;\n    }\n\n    // @notice Handles the response from the oracle for an LLM call\n    // @param runId The ID of the chat run\n    // @param response The response from the oracle\n    // @dev Called by teeML oracle\n    function onOracleLlmResponse(\n        uint256 runId,\n        string memory response,\n        string memory /*errorMessage*/\n    )\n        public\n        onlyOracle\n    {\n        CandidateProposal storage proposal = proposals[runId];\n        Message storage lastMessage = messages[runId][proposal.messagesCount - 1];\n        require(\n            keccak256(abi.encodePacked(lastMessage.role)) == keccak256(abi.encodePacked(\"user\")),\n            \"No message to respond to\"\n        );\n\n        Message memory newMessage = createTextMessage(\"assistant\", response);\n        messages[runId][proposal.messagesCount] = newMessage;\n        proposal.messagesCount++;\n    }\n\n    // @notice Handles the response from the oracle for a knowledge base query\n    // @param runId The ID of the chat run\n    // @param documents The array of retrieved documents\n    // @dev Called by teeML oracle\n    function onOracleKnowledgeBaseQueryResponse(\n        uint256 runId,\n        string[] memory documents,\n        string memory /*errorMessage*/\n    )\n        public\n        onlyOracle\n    {\n        CandidateProposal storage proposal = proposals[runId];\n        Message storage lastMessage = messages[runId][proposal.messagesCount - 1];\n        require(\n            keccak256(abi.encodePacked(lastMessage.role)) == keccak256(abi.encodePacked(\"user\")),\n            \"No message to add context to\"\n        );\n\n        // Start with the original message content\n        string memory newContent = lastMessage.content.value;\n\n        // Append \"Relevant context:\\n\" only if there are documents\n        if (documents.length > 0) {\n            newContent = string(abi.encodePacked(newContent, \"\\n\\nRelevant context:\\n\"));\n        }\n\n        // Iterate through the documents and append each to the newContent\n        for (uint256 i = 0; i < documents.length; i++) {\n            newContent = string(abi.encodePacked(newContent, documents[i], \"\\n\"));\n        }\n\n        // Finally, set the lastMessage content to the newly constructed string\n        lastMessage.content.value = newContent;\n\n        // Call LLM\n        IOracle(oracleAddress).createLlmCall(runId);\n    }\n\n    // @notice Creates a text message with the given role and content\n    // @param role The role of the message\n    // @param content The content of the message\n    // @return The created message\n    function createTextMessage(string memory role, string memory content) private pure returns (Message memory) {\n        MessageContent memory newContent = MessageContent({ contentType: \"text\", value: content });\n        Message memory newMessage = Message({ role: role, content: newContent });\n        return newMessage;\n    }\n\n    function concatenateProposal(string memory _title, string memory _body) internal pure returns (string memory) {\n        return string(abi.encodePacked(\"Title: \", _title, \"\\nBody: \", _body));\n    }\n\n    // @notice Retrieves the message history contents of a proposal\n    // @param proposalID The ID of the proposal\n    // @return An array of message contents\n    // @dev Called by teeML oracle\n    function getMessageHistoryContents(uint256 proposalId) public view returns (string[] memory) {\n        uint256 messagesLength = proposals[proposalId].messagesCount;\n        string[] memory previousMessages = new string[](messagesLength);\n        for (uint256 i = 0; i < messagesLength; i++) {\n            previousMessages[i] = messages[proposalId][i].content.value;\n        }\n        return previousMessages;\n    }\n\n    // @notice Retrieves the roles of the messages in a proposal\n    // @param chatId The ID of the proposal\n    // @return An array of message roles\n    // @dev Called by teeML oracle\n    function getMessageHistoryRoles(uint256 proposalId) public view returns (string[] memory) {\n        uint256 messagesLength = proposals[proposalId].messagesCount;\n        string[] memory roles = new string[](messagesLength);\n        for (uint256 i = 0; i < messagesLength; i++) {\n            roles[i] = messages[proposalId][i].role;\n        }\n        return roles;\n    }\n}\n"},"src/interfaces/IOracle.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\ninterface IOracle {\n    struct Content {\n        string contentType;\n        string value;\n    }\n\n    struct Message {\n        string role;\n        Content[] content;\n    }\n\n    struct OpenAiRequest {\n        // \"gpt-4-turbo\", \"gpt-4-turbo-preview\" or \"gpt-3.5-turbo-1106\"\n        string model;\n        // int -20 - 20, Mapped to float -2.0 - 2.0. If bigger than 20 then null\n        int8 frequencyPenalty;\n        // JSON string or empty string\n        string logitBias;\n        // 0 for null\n        uint32 maxTokens;\n        // int -20 - 20, Mapped to float -2.0 - 2.0. If bigger than 20 then null\n        int8 presencePenalty;\n        // JSON string or empty string\n        string responseFormat;\n        // 0 for null\n        uint256 seed;\n        // empty str for null\n        string stop;\n        // 0-20, > 20 for null\n        uint256 temperature;\n        // 0-100  percentage, > 100 for null\n        uint256 topP;\n        // JSON list for tools in OpenAI format, empty for null, names have to match the supported tools\n        string tools;\n        // \"none\", \"auto\" or empty str which defaults to auto on OpenAI side\n        string toolChoice;\n        string user;\n    }\n\n    struct OpenAiResponse {\n        string id;\n        // either content is an empty str or functionName and functionArguments\n        string content;\n        string functionName;\n        string functionArguments;\n        uint64 created;\n        string model;\n        string systemFingerprint;\n        // kind of pointless since its always \"chat.completion\"?\n        string object;\n        uint32 completionTokens;\n        uint32 promptTokens;\n        uint32 totalTokens;\n    }\n\n    struct GroqRequest {\n        // \"llama3-8b-8192\", \"llama3-70b-8192\", \"mixtral-8x7b-32768\" or \"gemma-7b-it\"\n        string model;\n        // int -20 - 20, Mapped to float -2.0 - 2.0. If bigger than 20 then null\n        int8 frequencyPenalty;\n        // JSON string or empty string\n        string logitBias;\n        // 0 for null\n        uint32 maxTokens;\n        // int -20 - 20, Mapped to float -2.0 - 2.0. If bigger than 20 then null\n        int8 presencePenalty;\n        // JSON string or empty string\n        string responseFormat;\n        // 0 for null\n        uint256 seed;\n        // empty str for null\n        string stop;\n        // 0-20, > 20 for null\n        uint256 temperature;\n        // 0-100  percentage, > 100 for null\n        uint256 topP;\n        string user;\n    }\n\n    struct GroqResponse {\n        string id;\n        string content;\n        uint64 created;\n        string model;\n        string systemFingerprint;\n        // kind of pointless since its always \"chat.completion\"?\n        string object;\n        uint32 completionTokens;\n        uint32 promptTokens;\n        uint32 totalTokens;\n    }\n\n    struct LlmRequest {\n        // \"claude-3-5-sonnet-20240620\", \"claude-3-opus-20240229\", \"claude-3-sonnet-20240229\",\n        // \"claude-3-haiku-20240307\", \"claude-2.1\", \"claude-2.0\", \"claude-instant-1.2\"\n        string model;\n        // int -20 - 20, Mapped to float -2.0 - 2.0. If bigger than 20 then null\n        int8 frequencyPenalty;\n        // JSON string or empty string\n        string logitBias;\n        // 0 for null\n        uint32 maxTokens;\n        // int -20 - 20, Mapped to float -2.0 - 2.0. If bigger than 20 then null\n        int8 presencePenalty;\n        // JSON string or empty string\n        string responseFormat;\n        // 0 for null\n        uint256 seed;\n        // empty str for null\n        string stop;\n        // 0-20, > 20 for null\n        uint256 temperature;\n        // 0-100  percentage, > 100 for null\n        uint256 topP;\n        // JSON list for tools in OpenAI format, empty for null, names have to match the supported tools\n        string tools;\n        // \"none\", \"auto\" or empty str which defaults to auto on OpenAI side\n        string toolChoice;\n        string user;\n    }\n\n    struct LlmResponse {\n        string id;\n        // either content is an empty str or functionName and functionArguments\n        string content;\n        string functionName;\n        string functionArguments;\n        uint64 created;\n        string model;\n        string systemFingerprint;\n        // kind of pointless since its always \"chat.completion\"?\n        string object;\n        uint32 completionTokens;\n        uint32 promptTokens;\n        uint32 totalTokens;\n    }\n\n    struct KnowledgeBaseQueryRequest {\n        string cid;\n        string query;\n        uint32 num_documents;\n    }\n\n    function createLlmCall(uint256 promptId) external returns (uint256);\n\n    function createLlmCall(uint256 promptId, LlmRequest memory request) external returns (uint256);\n\n    function createGroqLlmCall(uint256 promptId, GroqRequest memory request) external returns (uint256);\n\n    function createOpenAiLlmCall(uint256 promptId, OpenAiRequest memory request) external returns (uint256);\n\n    function createFunctionCall(\n        uint256 functionCallbackId,\n        string memory functionType,\n        string memory functionInput\n    )\n        external\n        returns (uint256 i);\n\n    function createKnowledgeBaseQuery(\n        uint256 kbQueryCallbackId,\n        string memory cid,\n        string memory query,\n        uint32 num_documents\n    )\n        external\n        returns (uint256 i);\n}\n"}},"settings":{"remappings":["@prb/test/=node_modules/@prb/test/","@openzeppelin/=node_modules/@openzeppelin/","forge-std/=node_modules/forge-std/"],"optimizer":{"enabled":true,"runs":10000},"metadata":{"useLiteralContent":false,"bytecodeHash":"none","appendCBOR":true},"outputSelection":{"*":{"*":["abi","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","metadata"]}},"evmVersion":"shanghai","viaIR":false,"libraries":{}}}
